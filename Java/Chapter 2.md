# Chapter 2 类与对象

- 抽象、封装、继承、多态

## 1.抽象

- 忽略问题中与当前目标无关的方面
- 只关注与当前目标有关的方面

例：钟表

- 数据（属性）
  - `int Hour; int Minute; int Second;`	
- 方法（行为）
  - `SetTime(); ShowTime();`

## 2.封装

- 利用抽象数据类型将数据和基于数据的操作封装在一起
- 用户只能看到对象的封装界面信息，对象的内部细节对用户是隐蔽的
- 目的在于将对象的使用者和设计者分开，使用者不必知道行为实现的细节

## 3.继承

- 基于已有类产生新类的机制
- 新的类可以获得已有类（super）的属性和行为，称新的类为已有类的子类
- 继承中子类继承了超类的特性，包括方法和实例变量
- 子类可以修改继承的方法或者增加新的方法
- java只支持单继承（一个子类只有一个单一的超类）

## 4.多态

- 在有继承的情况下，超类和子类可以响应相同的参数，但是可以采取不同的处理方式，和内部的方法有关

## 2.2-1 类的声明和对象的创建

### 类和对象的关系

- 类是对一类对象的描述
- 对象是类的具体实例

类的定义中的关键字

- class
  - 表明是一个类
- extends
  - 如果这个类从某一父类派生出来，那么用extends
- implements
  - 如果所声明的类需要实现某些接口
- public
  - 表示为公有类
- abstract
  - 抽象类
- final
  - 终结类，不可继承

### 对象引用声明

- 语法
  - 类名 引用变量名：`Clock aclock`

### 对象的创建

- 语法
  - new<类>()：`aclock = new Clock()`
  - new：在内存中为Clock类型的对象分配内存空间，返回对象的引用

## 2.2-2 数据成员

- 数据成员
  - 表示对象的状态
  - 可以是任何类型
- 说明
  - public、protected、private为访问控制符
  - static指明是一个静态成员变量（类变量）
  - final变量值不能修改
  - transient表示变量不需要序列化：存文件时用密码用transient修饰
  - volatile：共享变量
- 实例变量
  - 没有static修饰
  - 存储的所有实例都需要的属性，不同实例的属性值可能不同
  - 实例变量需要通过对象名去访问：`对象名.实例变量名`
- 类变量（静态变量）
  - static修饰
  - 在类中只有一个值
  - 类初始化的时候就被赋值
  - 适用情况
    - 类中所有对象都相同的属性
    - 经常需要共享的数据
    - 系统中的常量值
  - 引用格式：`类名/对象名.类变量名`

## 2.2-3 方法成员

- public、protected、private控制访问权限
- static表明是一个类方法（静态方法）
- final：终结方法
- abstract：抽象方法：只有方法原型而没有具体方法
- native：集成java和其他语言
- synchronized：控制多个并发线程对共享数据的访问

- 实例方法
  - 特定对象的行为
  - 不用static
  - 调用：`对象名.方法名(参数列表)`
  - 参数传递
    - 值传递：参数类型为基本数据类型
    - 引用传递：参数类型为对象类型或数组
- 类方法（静态方法）
  - static修饰
  - 不能被声明为抽象的
  - 可以通过类名调用
- 可变长参数
  - 省略号表示：`String...s`表示`String[] s`

## 2.2-4 包

- 包是一组类的集合
- 一个包可以包含若干个类文件，或者包含若干个子包
- 作用
  - 类名的空间管理，利用包来划分名字空间可以避免类名冲突
- 命名
  - 包名必须独一无二
  - 使用小写字母
  - 建议
    - 机构的Internet域名反序，作为包的前导
    - 不可标识字符用下划线代替
    - 关键字冲突则后缀下划线
    - 若以数字或其他不可标识字符起始，则前面加下划线
- 编译单元
  - 所属包的声明
  - Import包的声明，导入外部类
  - 类和接口的声明（自己的）
- 一个编译单元中只能有一个public类，类名与文件名相同，其他类一般是public的辅助类
- 声明
  - 命名的包：`package Mypackage`
  - 默认包： 不含包声明的默认编译单元
- 引入
  - import
- 静态引入
  - 单一引入：引入某一个指定的静态成员
  - 全体引入：引入类中所有的静态成员（*）

## 2.2-5-类的访问权限控制

- 类的成员访问权限控制

  - 公有public：可以被其他任何方法访问
  - 保护protected：只可被同一类及其子类的方法访问
  - 私有private：只可被同一类的方法访问
  - 默认default：仅允许同一个包内的访问

- 公有接口

  - get方法：取得属性变量的值

    - ```java
      public int getRadius(){
      	return radius;
      }
      ```

  - set方法：修改属性变量的值
  
    - ```java
      public void setRadius(){
      	radius = r;
      }
      ```
  
  - this关键字
  
    - 方法内的局部变量（包括形参）名与实例变量名相同，则方法体内访问实例变量时需要用this关键字
  
    - ```java
      public void setRadius(int radius){
      	this.radius = radius;
      }
      ```

## 2.3-1 对象初始化

- 使用**构造方法**对对象进行初始化
- 对象回收
  - 不再被使用时需要回收
- 构造方法
  - 方法名和类名相同
  - 不定义返回类型
  - 通常被声明public
  - 可以有任意个参数
  - 主要作用是完成对象的初始化
  - 不能在程序中显示调用
  - 在生成一个对象时，会自动调用该类的构造方法为新对象初始化
  - 未声明则默认构造方法
    - 默认构造方法没有参数，方法体为空
- 自定义构造方法与方法重载
  - 生成对象时传送初始值来进行初始化
  - 构造方法可以重载
    - 重载：一个类中有两个及以上同名的方法，但参数表不同，每次通过参数表来找到调用的方法
  - 只要声明了构造方法，编译器就不再使用默认的
  - 也可以声明一个无参构造方法
- 声明构造方法时使用this关键字
  - this可以调用一个构造方法中的另外的构造方法（通常用参数少的构造方法调用参数多的构造方法）
- final变量的初始化
  - final实例变量在类中定义时给初始值
  - final类变量必须在声明的同时初始化

## 2.3-2 内存回收

- 无用对象
  - 离开了作用域
  - 无引用指向对象
- java调用finalize()方法回收资源
- finalize()
  - java.lang.Object类中，是所有子类的超类
  - 用于释放资源
  - 可以重写finalize()
  - 可能在任何时机任何次序执行